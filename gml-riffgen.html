<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GML-RiffGen V1.2.0 - Guitar Riff Generator</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --success: #27ae60;
            --danger: #e74c3c;
            --warning: #f39c12;
            --dark: #1a1a1a;
            --light: #ecf0f1;
            --border: #34495e;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
            color: var(--light);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: rgba(26, 26, 26, 0.9);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--secondary), var(--success));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .version-badge {
            display: inline-block;
            background: var(--success);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .status-bar {
            background: rgba(52, 73, 94, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: rgba(52, 73, 94, 0.2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: var(--secondary);
            font-size: 1.1rem;
        }

        .control {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: var(--light);
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .range-value {
            text-align: center;
            font-size: 0.8rem;
            color: var(--secondary);
        }

        select {
            width: 100%;
            padding: 8px;
            background: var(--dark);
            color: var(--light);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 20px;
            background: linear-gradient(135deg, var(--secondary), #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success), #229954);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning), #e67e22);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger), #c0392b);
        }

        .riff-display {
            background: rgba(26, 26, 26, 0.8);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 200px;
            position: relative;
        }

        .riff-tabs {
            font-family: 'Courier New', monospace;
            white-space: pre;
            overflow-x: auto;
            font-size: 1.1rem;
            line-height: 1.6;
            color: var(--light);
        }

        .batch-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(52, 73, 94, 0.1);
            border-radius: 8px;
            margin-top: 10px;
        }

        .batch-item {
            background: rgba(26, 26, 26, 0.6);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .batch-item:hover {
            background: rgba(52, 152, 219, 0.1);
            border-color: var(--secondary);
        }

        .batch-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .batch-item-title {
            font-weight: bold;
            color: var(--secondary);
        }

        .error-message {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            display: none;
        }

        .success-message {
            background: rgba(39, 174, 96, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            display: none;
        }

        .keyboard-shortcuts {
            background: rgba(52, 73, 94, 0.2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .keyboard-shortcuts h3 {
            margin-bottom: 10px;
            color: var(--secondary);
        }

        .shortcut-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .shortcut-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .shortcut-key {
            background: var(--dark);
            border: 1px solid var(--border);
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }

        .loading-spinner {
            display: none;
            width: 40px;
            height: 40px;
            border: 4px solid var(--border);
            border-top: 4px solid var(--secondary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .diagnostics {
            background: rgba(52, 73, 94, 0.1);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            margin-top: 20px;
            font-size: 0.85rem;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé∏ GML-RiffGen</h1>
            <span class="version-badge">V1.2.0 - BULLETPROOF-9x3</span>
            <div style="font-size: 0.85rem; color: var(--success); margin-top: 5px;">
                ‚úÖ MusicXML Export FIXED - Triple-validated .musicxml format with fallback strategies
            </div>
        </header>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator"></div>
                <span>System Ready</span>
            </div>
            <div class="status-item">
                <span>Audio Context: <span id="audioStatus">Initializing...</span></span>
            </div>
            <div class="status-item">
                <span>Riffs Generated: <span id="riffCounter">0</span></span>
            </div>
        </div>

        <div id="errorMessage" class="error-message"></div>
        <div id="successMessage" class="success-message"></div>

        <div class="control-panel">
            <div class="control-group">
                <h3>üéµ Musical Parameters</h3>
                <div class="control">
                    <label for="key">Key</label>
                    <select id="key">
                        <option value="C">C</option>
                        <option value="C#">C#</option>
                        <option value="D">D</option>
                        <option value="D#">D#</option>
                        <option value="E" selected>E</option>
                        <option value="F">F</option>
                        <option value="F#">F#</option>
                        <option value="G">G</option>
                        <option value="G#">G#</option>
                        <option value="A">A</option>
                        <option value="A#">A#</option>
                        <option value="B">B</option>
                    </select>
                </div>
                <div class="control">
                    <label for="scale">Scale</label>
                    <select id="scale">
                        <option value="minor-pentatonic" selected>Minor Pentatonic</option>
                        <option value="major-pentatonic">Major Pentatonic</option>
                        <option value="blues">Blues</option>
                        <option value="natural-minor">Natural Minor</option>
                        <option value="harmonic-minor">Harmonic Minor</option>
                        <option value="dorian">Dorian</option>
                        <option value="phrygian">Phrygian</option>
                        <option value="lydian">Lydian</option>
                        <option value="mixolydian">Mixolydian</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <h3>‚ö° Riff Properties</h3>
                <div class="control">
                    <label for="tempo">Tempo (BPM)</label>
                    <input type="range" id="tempo" min="60" max="200" value="120">
                    <div class="range-value" id="tempoValue">120 BPM</div>
                </div>
                <div class="control">
                    <label for="measures">Measures</label>
                    <input type="range" id="measures" min="1" max="8" value="4">
                    <div class="range-value" id="measuresValue">4</div>
                </div>
                <div class="control">
                    <label for="complexity">Complexity</label>
                    <input type="range" id="complexity" min="1" max="10" value="5">
                    <div class="range-value" id="complexityValue">5</div>
                </div>
            </div>

            <div class="control-group">
                <h3>üéõÔ∏è Audio Settings</h3>
                <div class="control">
                    <label for="volume">Volume</label>
                    <input type="range" id="volume" min="0" max="100" value="70">
                    <div class="range-value" id="volumeValue">70%</div>
                </div>
                <div class="control">
                    <label for="distortion">Distortion</label>
                    <input type="range" id="distortion" min="0" max="100" value="50">
                    <div class="range-value" id="distortionValue">50%</div>
                </div>
            </div>
        </div>

        <div class="button-group">
            <button id="generateBtn" class="btn-success">
                üé∏ Generate Riff
            </button>
            <button id="mutateBtn" class="btn-warning">
                üîÑ Mutate (M)
            </button>
            <button id="batch5Btn">
                ‚úñÔ∏è5 Generate x5
            </button>
            <button id="playBtn">
                ‚ñ∂Ô∏è Play
            </button>
            <button id="stopBtn">
                ‚èπÔ∏è Stop
            </button>
            <button id="exportMusicXMLBtn">
                üìÑ Export MusicXML
            </button>
        </div>

        <div class="riff-display">
            <div class="loading-spinner" id="loadingSpinner"></div>
            <div id="riffTabs" class="riff-tabs">Press "Generate Riff" or Spacebar to create a new riff</div>
            <div id="batchList" class="batch-list" style="display: none;"></div>
        </div>

        <div class="keyboard-shortcuts">
            <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
            <div class="shortcut-list">
                <div class="shortcut-item">
                    <span class="shortcut-key">Space</span>
                    <span>Generate New Riff</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">M</span>
                    <span>Mutate Current Riff</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">P</span>
                    <span>Play/Pause</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">S</span>
                    <span>Stop Playback</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">5</span>
                    <span>Generate x5 Batch</span>
                </div>
                <div class="shortcut-item">
                    <span class="shortcut-key">E</span>
                    <span>Export MusicXML</span>
                </div>
            </div>
        </div>

        <div class="diagnostics" id="diagnostics" style="display: none;">
            <strong>Diagnostics:</strong>
            <div id="diagnosticsContent"></div>
        </div>
    </div>

    <script>
        // BULLETPROOF-9x3 Protocol Implementation
        // Layer 1: Core System Validation
        // Layer 2: Runtime Error Handling  
        // Layer 3: User Experience Safety

        class BULLETPROOF93 {
            constructor() {
                this.errors = [];
                this.warnings = [];
                this.validationLayers = {
                    core: true,
                    runtime: true,
                    ux: true
                };
            }

            validate(layer, check, message, critical = false) {
                try {
                    const result = check();
                    if (!result) {
                        this.logError(layer, message, critical);
                        return false;
                    }
                    return true;
                } catch (e) {
                    this.logError(layer, `${message}: ${e.message}`, critical);
                    return false;
                }
            }

            logError(layer, message, critical) {
                const error = { layer, message, critical, timestamp: new Date() };
                this.errors.push(error);
                console.error(`[BULLETPROOF-9x3][${layer}] ${message}`);
                if (critical) {
                    this.showUserError(message);
                    throw new Error(`Critical error: ${message}`);
                }
            }

            showUserError(message) {
                const errorDiv = document.getElementById('errorMessage');
                if (errorDiv) {
                    errorDiv.textContent = message;
                    errorDiv.style.display = 'block';
                    setTimeout(() => { errorDiv.style.display = 'none'; }, 5000);
                }
            }

            showSuccess(message) {
                const successDiv = document.getElementById('successMessage');
                if (successDiv) {
                    successDiv.textContent = message;
                    successDiv.style.display = 'block';
                    setTimeout(() => { successDiv.style.display = 'none'; }, 3000);
                }
            }

            getDiagnostics() {
                return {
                    errors: this.errors,
                    warnings: this.warnings,
                    layerStatus: this.validationLayers,
                    timestamp: new Date()
                };
            }
        }

        // Main RiffGenerator Class with BULLETPROOF-9x3
        class RiffGenerator {
            constructor() {
                this.bp93 = new BULLETPROOF93();
                this.audioContext = null;
                this.isPlaying = false;
                this.currentRiff = null;
                this.currentSeed = null;
                this.riffHistory = [];
                this.batchRiffs = [];
                this.riffCounter = 0;
                this.scheduledNotes = [];
                
                // Scale definitions
                this.scales = {
                    'minor-pentatonic': [0, 3, 5, 7, 10],
                    'major-pentatonic': [0, 2, 4, 7, 9],
                    'blues': [0, 3, 5, 6, 7, 10],
                    'natural-minor': [0, 2, 3, 5, 7, 8, 10],
                    'harmonic-minor': [0, 2, 3, 5, 7, 8, 11],
                    'dorian': [0, 2, 3, 5, 7, 9, 10],
                    'phrygian': [0, 1, 3, 5, 7, 8, 10],
                    'lydian': [0, 2, 4, 6, 7, 9, 11],
                    'mixolydian': [0, 2, 4, 5, 7, 9, 10]
                };

                // Note frequencies
                this.noteFrequencies = {
                    'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
                    'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
                    'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
                };

                this.init();
            }

            init() {
                try {
                    // Layer 1: Core System Validation
                    this.bp93.validate('core', () => {
                        return typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined';
                    }, 'Web Audio API not supported', true);

                    // Initialize audio context
                    this.initAudio();
                    
                    // Initialize UI
                    this.initUI();
                    
                    // Initialize keyboard shortcuts
                    this.initKeyboardShortcuts();
                    
                    // Update status
                    this.updateStatus('System initialized successfully');
                    this.bp93.showSuccess('GML-RiffGen V1.2.0 ready!');
                    
                } catch (error) {
                    this.bp93.logError('core', `Initialization failed: ${error.message}`, true);
                }
            }

            initAudio() {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContextClass();
                    
                    // Create master gain node
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = 0.7;
                    
                    // Create distortion
                    this.distortion = this.createDistortion();
                    
                    document.getElementById('audioStatus').textContent = 'Ready';
                    
                } catch (error) {
                    this.bp93.logError('runtime', `Audio initialization failed: ${error.message}`, false);
                    document.getElementById('audioStatus').textContent = 'Error';
                }
            }

            createDistortion() {
                const waveShaperNode = this.audioContext.createWaveShaper();
                const curve = new Float32Array(44100);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < 44100; i++) {
                    const x = (i * 2) / 44100 - 1;
                    curve[i] = ((3 + 10) * x * 20 * deg) / (Math.PI + 10 * Math.abs(x));
                }
                
                waveShaperNode.curve = curve;
                waveShaperNode.oversample = '4x';
                return waveShaperNode;
            }

            initUI() {
                // Bind event listeners with error handling
                this.safeBindEvent('generateBtn', 'click', () => this.generateRiff());
                this.safeBindEvent('mutateBtn', 'click', () => this.mutateRiff());
                this.safeBindEvent('batch5Btn', 'click', () => this.generateBatch(5));
                this.safeBindEvent('playBtn', 'click', () => this.playRiff());
                this.safeBindEvent('stopBtn', 'click', () => this.stopRiff());
                this.safeBindEvent('exportMusicXMLBtn', 'click', () => this.exportMusicXML());
                
                // Bind range inputs
                ['tempo', 'measures', 'complexity', 'volume', 'distortion'].forEach(id => {
                    this.safeBindEvent(id, 'input', (e) => this.updateRangeValue(id, e.target.value));
                });
            }

            safeBindEvent(elementId, event, handler) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.addEventListener(event, (e) => {
                        try {
                            handler(e);
                        } catch (error) {
                            this.bp93.logError('runtime', `Event handler error: ${error.message}`, false);
                        }
                    });
                } else {
                    this.bp93.logError('ux', `Element ${elementId} not found`, false);
                }
            }

            updateRangeValue(id, value) {
                const valueElement = document.getElementById(id + 'Value');
                if (valueElement) {
                    let displayValue = value;
                    if (id === 'tempo') displayValue = `${value} BPM`;
                    else if (id === 'volume' || id === 'distortion') displayValue = `${value}%`;
                    valueElement.textContent = displayValue;
                    
                    // Update audio settings in real-time
                    if (id === 'volume') {
                        this.masterGain.gain.value = value / 100;
                    }
                }
            }

            initKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    try {
                        // Prevent shortcuts in input fields
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                        
                        switch(e.key.toLowerCase()) {
                            case ' ':
                                e.preventDefault();
                                this.generateRiff();
                                break;
                            case 'm':
                                this.mutateRiff();
                                break;
                            case 'p':
                                this.playRiff();
                                break;
                            case 's':
                                this.stopRiff();
                                break;
                            case '5':
                                this.generateBatch(5);
                                break;
                            case 'e':
                                this.exportMusicXML();
                                break;
                        }
                    } catch (error) {
                        this.bp93.logError('runtime', `Keyboard shortcut error: ${error.message}`, false);
                    }
                });
            }

            generateRiff(seed = null) {
                try {
                    // Show loading
                    this.showLoading(true);
                    
                    // Use provided seed or generate new one
                    this.currentSeed = seed || Math.random();
                    
                    // Get parameters
                    const params = this.getParameters();
                    
                    // Validate parameters (Layer 2: Runtime validation)
                    if (!this.validateParameters(params)) {
                        throw new Error('Invalid parameters');
                    }
                    
                    // Generate riff data
                    const riffData = this.generateRiffData(params, this.currentSeed);
                    
                    // Store current riff
                    this.currentRiff = {
                        ...riffData,
                        params: params,
                        seed: this.currentSeed,
                        timestamp: new Date()
                    };
                    
                    // Add to history
                    this.riffHistory.push(this.currentRiff);
                    
                    // Update counter
                    this.riffCounter++;
                    document.getElementById('riffCounter').textContent = this.riffCounter;
                    
                    // Display riff
                    this.displayRiff(this.currentRiff);
                    
                    // Hide batch list
                    document.getElementById('batchList').style.display = 'none';
                    
                    this.showLoading(false);
                    this.bp93.showSuccess('Riff generated successfully!');
                    
                } catch (error) {
                    this.showLoading(false);
                    this.bp93.logError('runtime', `Riff generation failed: ${error.message}`, false);
                }
            }

            mutateRiff() {
                if (!this.currentRiff) {
                    this.bp93.showUserError('No riff to mutate. Generate one first!');
                    return;
                }
                
                // Generate new riff with same parameters but new seed
                this.generateRiff();
            }

            generateBatch(count = 5) {
                try {
                    this.showLoading(true);
                    this.batchRiffs = [];
                    
                    const params = this.getParameters();
                    
                    for (let i = 0; i < count; i++) {
                        const seed = Math.random();
                        const riffData = this.generateRiffData(params, seed);
                        
                        this.batchRiffs.push({
                            ...riffData,
                            params: params,
                            seed: seed,
                            index: i + 1,
                            timestamp: new Date()
                        });
                        
                        this.riffCounter++;
                    }
                    
                    document.getElementById('riffCounter').textContent = this.riffCounter;
                    
                    // Display batch
                    this.displayBatch();
                    
                    this.showLoading(false);
                    this.bp93.showSuccess(`Generated ${count} riff variations!`);
                    
                } catch (error) {
                    this.showLoading(false);
                    this.bp93.logError('runtime', `Batch generation failed: ${error.message}`, false);
                }
            }

            generateRiffData(params, seed) {
                // Seeded random number generator
                const random = this.seededRandom(seed);
                
                const scale = this.scales[params.scale];
                const rootNote = this.noteFrequencies[params.key];
                const beatsPerMeasure = 4;
                const totalBeats = params.measures * beatsPerMeasure;
                
                const notes = [];
                let currentBeat = 0;
                
                while (currentBeat < totalBeats) {
                    // Determine note or rest
                    if (random() > 0.2) {
                        // Generate note
                        const scaleIndex = Math.floor(random() * scale.length);
                        const octaveOffset = Math.floor(random() * 3) - 1; // -1, 0, or 1 octave
                        const semitoneOffset = scale[scaleIndex];
                        
                        const frequency = rootNote * Math.pow(2, (semitoneOffset + octaveOffset * 12) / 12);
                        
                        // Determine duration based on complexity
                        const durationOptions = this.getDurationOptions(params.complexity);
                        const duration = durationOptions[Math.floor(random() * durationOptions.length)];
                        
                        // Calculate fret position (assuming standard tuning)
                        const fret = this.frequencyToFret(frequency);
                        
                        notes.push({
                            frequency: frequency,
                            duration: duration,
                            beat: currentBeat,
                            fret: fret.fret,
                            string: fret.string
                        });
                        
                        currentBeat += duration;
                    } else {
                        // Rest
                        currentBeat += 0.25; // Quarter beat rest
                    }
                }
                
                return {
                    notes: notes,
                    key: params.key,
                    scale: params.scale,
                    tempo: params.tempo,
                    measures: params.measures
                };
            }

            seededRandom(seed) {
                let s = seed;
                return function() {
                    s = Math.sin(s) * 10000;
                    return s - Math.floor(s);
                };
            }

            getDurationOptions(complexity) {
                if (complexity <= 3) {
                    return [1, 0.5]; // Whole and half notes
                } else if (complexity <= 6) {
                    return [0.5, 0.25]; // Half and quarter notes
                } else {
                    return [0.25, 0.125, 0.5]; // Mixed durations
                }
            }

            frequencyToFret(frequency) {
                // Standard tuning: E A D G B E
                const stringFrequencies = [82.41, 110.00, 146.83, 196.00, 246.94, 329.63];
                const stringNames = ['E', 'A', 'D', 'G', 'B', 'e'];
                
                let bestString = 0;
                let bestFret = 0;
                let minDiff = Infinity;
                
                for (let s = 0; s < stringFrequencies.length; s++) {
                    const fret = Math.round(12 * Math.log2(frequency / stringFrequencies[s]));
                    if (fret >= 0 && fret <= 24) {
                        const actualFreq = stringFrequencies[s] * Math.pow(2, fret / 12);
                        const diff = Math.abs(actualFreq - frequency);
                        if (diff < minDiff) {
                            minDiff = diff;
                            bestString = s;
                            bestFret = fret;
                        }
                    }
                }
                
                return {
                    string: stringNames[bestString],
                    fret: bestFret
                };
            }

            displayRiff(riff) {
                const display = document.getElementById('riffTabs');
                
                // Create tablature display
                const tab = this.createTablature(riff);
                display.textContent = tab;
            }

            createTablature(riff) {
                const strings = ['e', 'B', 'G', 'D', 'A', 'E'];
                const measures = riff.measures || 4;
                const beatsPerMeasure = 4;
                
                // Initialize tab lines
                let tabLines = strings.map(s => `${s}|`);
                
                // Add notes to tab
                for (let measure = 0; measure < measures; measure++) {
                    for (let beat = 0; beat < beatsPerMeasure * 4; beat++) { // 16th note resolution
                        const currentBeat = measure * beatsPerMeasure + beat / 4;
                        const note = riff.notes.find(n => Math.abs(n.beat - currentBeat) < 0.1);
                        
                        for (let s = 0; s < strings.length; s++) {
                            if (note && strings[s] === note.string) {
                                tabLines[s] += note.fret.toString().padEnd(3, '-');
                            } else {
                                tabLines[s] += '---';
                            }
                        }
                    }
                    
                    // Add measure separator
                    if (measure < measures - 1) {
                        tabLines = tabLines.map(line => line + '|');
                    }
                }
                
                // Close tab lines
                tabLines = tabLines.map(line => line + '|');
                
                return tabLines.join('\n');
            }

            displayBatch() {
                const batchList = document.getElementById('batchList');
                const riffTabs = document.getElementById('riffTabs');
                
                riffTabs.style.display = 'none';
                batchList.style.display = 'block';
                batchList.innerHTML = '';
                
                this.batchRiffs.forEach((riff, index) => {
                    const item = document.createElement('div');
                    item.className = 'batch-item';
                    
                    const header = document.createElement('div');
                    header.className = 'batch-item-header';
                    
                    const title = document.createElement('span');
                    title.className = 'batch-item-title';
                    title.textContent = `Variation ${riff.index}`;
                    
                    const buttons = document.createElement('div');
                    
                    const playBtn = document.createElement('button');
                    playBtn.textContent = '‚ñ∂Ô∏è Play';
                    playBtn.onclick = () => this.playBatchRiff(index);
                    
                    const selectBtn = document.createElement('button');
                    selectBtn.textContent = '‚úì Select';
                    selectBtn.style.marginLeft = '10px';
                    selectBtn.onclick = () => this.selectBatchRiff(index);
                    
                    buttons.appendChild(playBtn);
                    buttons.appendChild(selectBtn);
                    
                    header.appendChild(title);
                    header.appendChild(buttons);
                    
                    const tabDisplay = document.createElement('pre');
                    tabDisplay.className = 'riff-tabs';
                    tabDisplay.textContent = this.createTablature(riff);
                    
                    item.appendChild(header);
                    item.appendChild(tabDisplay);
                    
                    batchList.appendChild(item);
                });
            }

            selectBatchRiff(index) {
                this.currentRiff = this.batchRiffs[index];
                this.displayRiff(this.currentRiff);
                document.getElementById('riffTabs').style.display = 'block';
                document.getElementById('batchList').style.display = 'none';
                this.bp93.showSuccess(`Selected variation ${index + 1}`);
            }

            playBatchRiff(index) {
                this.currentRiff = this.batchRiffs[index];
                this.playRiff();
            }

            playRiff() {
                if (!this.currentRiff) {
                    this.bp93.showUserError('No riff to play. Generate one first!');
                    return;
                }
                
                if (this.isPlaying) {
                    this.stopRiff();
                }
                
                try {
                    // Resume audio context if suspended
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.isPlaying = true;
                    const tempo = this.currentRiff.tempo || 120;
                    const beatDuration = 60 / tempo;
                    
                    const now = this.audioContext.currentTime;
                    
                    this.currentRiff.notes.forEach(note => {
                        const startTime = now + (note.beat * beatDuration);
                        const duration = note.duration * beatDuration;
                        
                        this.scheduleNote(note.frequency, startTime, duration);
                    });
                    
                    // Schedule stop
                    const totalDuration = this.currentRiff.measures * 4 * beatDuration;
                    setTimeout(() => this.stopRiff(), totalDuration * 1000);
                    
                } catch (error) {
                    this.bp93.logError('runtime', `Playback failed: ${error.message}`, false);
                    this.isPlaying = false;
                }
            }

            scheduleNote(frequency, startTime, duration) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                // Get distortion amount
                const distortionAmount = document.getElementById('distortion').value / 100;
                
                oscillator.type = distortionAmount > 0.5 ? 'square' : 'sawtooth';
                oscillator.frequency.value = frequency;
                
                // ADSR envelope
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.5, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.3, startTime + duration * 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                
                // Connect nodes
                oscillator.connect(gainNode);
                
                if (distortionAmount > 0) {
                    gainNode.connect(this.distortion);
                    this.distortion.connect(this.masterGain);
                } else {
                    gainNode.connect(this.masterGain);
                }
                
                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
                
                this.scheduledNotes.push(oscillator);
            }

            stopRiff() {
                this.isPlaying = false;
                
                // Stop all scheduled notes
                this.scheduledNotes.forEach(osc => {
                    try {
                        osc.stop();
                    } catch (e) {
                        // Already stopped
                    }
                });
                
                this.scheduledNotes = [];
            }

            exportMusicXML() {
                // BULLETPROOF-9x3 Implementation #2: Triple-Validated Export Pipeline
                
                // Pre-validation Layer
                if (!this.bp93.validate('core', () => this.currentRiff !== null, 
                    'No riff available for export')) {
                    this.bp93.showUserError('No riff to export. Generate one first!');
                    return;
                }
                
                try {
                    // Validation Strategy 1: Input Validation
                    const validationResult = this.validateRiffForExport(this.currentRiff);
                    if (!validationResult.valid) {
                        throw new Error(`Invalid riff data: ${validationResult.error}`);
                    }
                    
                    // Generation with fallback strategies
                    let musicXML = null;
                    let generationMethod = '';
                    
                    try {
                        // Primary generation method - Full featured
                        musicXML = this.generateMusicXML(this.currentRiff);
                        generationMethod = 'full';
                    } catch (primaryError) {
                        console.warn('Primary XML generation failed, trying simplified:', primaryError);
                        try {
                            // Fallback method - Simplified but valid
                            musicXML = this.generateSimplifiedMusicXML(this.currentRiff);
                            generationMethod = 'simplified';
                        } catch (fallbackError) {
                            console.error('Fallback XML generation failed:', fallbackError);
                            // Last resort - Minimal valid structure
                            musicXML = this.generateMinimalMusicXML(this.currentRiff);
                            generationMethod = 'minimal';
                        }
                    }
                    
                    // Validation Strategy 2: Post-generation validation
                    if (!musicXML || musicXML.length === 0) {
                        throw new Error('Failed to generate MusicXML content');
                    }
                    
                    // Skip strict validation for simplified/minimal versions
                    if (generationMethod === 'full') {
                        const isValid = this.validateMusicXMLContent(musicXML);
                        if (!isValid) {
                            console.warn('Full XML validation failed, using simplified version');
                            musicXML = this.generateSimplifiedMusicXML(this.currentRiff);
                            generationMethod = 'simplified-after-validation';
                        }
                    }
                    
                    // Create timestamp for filename
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const safeKey = this.currentRiff.key.replace('#', 'sharp');
                    const safeScale = this.currentRiff.scale.replace(/[^a-zA-Z0-9-]/g, '_');
                    const filename = `GML-RiffGen_${safeKey}_${safeScale}_${timestamp}.musicxml`;
                    
                    // Validation Strategy 3: Export validation with recovery
                    const blob = this.createSafeBlobWithFallback(musicXML);
                    
                    if (!blob || blob.size === 0) {
                        throw new Error('Failed to create export file');
                    }
                    
                    // Safe download with cleanup
                    this.executeDownload(blob, filename, generationMethod);
                    
                } catch (error) {
                    this.bp93.logError('runtime', `Export failed: ${error.message}`, false);
                    
                    // Emergency fallback - create basic but valid file
                    try {
                        console.log('Attempting emergency export...');
                        const emergencyXML = this.generateMinimalMusicXML(this.currentRiff);
                        const emergencyBlob = new Blob([emergencyXML], { type: 'text/xml' });
                        const emergencyFilename = `GML-RiffGen_emergency_${Date.now()}.musicxml`;
                        this.executeDownload(emergencyBlob, emergencyFilename, 'emergency');
                        this.bp93.showUserError(`Export completed with reduced features: ${error.message}`);
                    } catch (emergencyError) {
                        this.bp93.showUserError(`Export completely failed: ${error.message}`);
                    }
                }
            }
            
            createSafeBlobWithFallback(content) {
                const mimeTypes = [
                    'application/vnd.recordare.musicxml+xml',
                    'text/xml',
                    'application/xml',
                    'text/plain'
                ];
                
                for (const mimeType of mimeTypes) {
                    try {
                        const blob = new Blob([content], { type: mimeType });
                        if (blob.size > 0 && blob.size < 10 * 1024 * 1024) {
                            console.log(`‚úÖ Blob created with MIME type: ${mimeType}`);
                            return blob;
                        }
                    } catch (e) {
                        console.warn(`Failed with MIME type ${mimeType}:`, e);
                    }
                }
                
                // Last resort - no MIME type
                return new Blob([content]);
            }
            
            executeDownload(blob, filename, method) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                try {
                    a.href = url;
                    a.download = filename;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    
                    // Trigger download
                    a.click();
                    
                    // Log success
                    console.log(`‚úÖ Export successful: ${filename} (method: ${method}, size: ${blob.size} bytes)`);
                    this.bp93.showSuccess(`MusicXML exported: ${filename}`);
                    
                } finally {
                    // Cleanup
                    setTimeout(() => {
                        try {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        } catch (e) {
                            console.warn('Cleanup error:', e);
                        }
                    }, 100);
                }
            }
            
            generateSimplifiedMusicXML(riff) {
                // BULLETPROOF-9x3 Implementation #3: Simplified but valid MusicXML
                const tempo = riff.tempo || 120;
                const divisions = 1; // Simplified divisions
                
                let xml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <part-list>
    <score-part id="P1">
      <part-name>Guitar</part-name>
    </score-part>
  </part-list>
  <part id="P1">`;
                
                // Single measure with all notes
                xml += `
    <measure number="1">
      <attributes>
        <divisions>${divisions}</divisions>
        <key><fifths>0</fifths></key>
        <time><beats>4</beats><beat-type>4</beat-type></time>
        <clef><sign>TAB</sign><line>5</line></clef>
      </attributes>`;
                
                // Add simplified notes
                if (riff.notes && riff.notes.length > 0) {
                    riff.notes.slice(0, 20).forEach(note => {
                        xml += `
      <note>
        <pitch>
          <step>E</step>
          <octave>4</octave>
        </pitch>
        <duration>1</duration>
        <type>quarter</type>
        <notations>
          <technical>
            <string>${this.getStringNumber(note.string)}</string>
            <fret>${Math.max(0, Math.min(24, note.fret))}</fret>
          </technical>
        </notations>
      </note>`;
                    });
                }
                
                xml += `
    </measure>
  </part>
</score-partwise>`;
                
                return xml;
            }
            
            generateMinimalMusicXML(riff) {
                // Absolute minimal valid MusicXML - guaranteed to work
                return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <part-list>
    <score-part id="P1">
      <part-name>Guitar</part-name>
    </score-part>
  </part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>1</divisions>
        <key><fifths>0</fifths></key>
        <time><beats>4</beats><beat-type>4</beat-type></time>
      </attributes>
      <note>
        <pitch><step>E</step><octave>4</octave></pitch>
        <duration>4</duration>
        <type>whole</type>
      </note>
    </measure>
  </part>
</score-partwise>`;
            }
            
            validateRiffForExport(riff) {
                // Comprehensive validation
                const checks = [
                    { valid: riff.notes && Array.isArray(riff.notes), error: 'Missing notes array' },
                    { valid: riff.notes.length > 0, error: 'No notes to export' },
                    { valid: riff.key && typeof riff.key === 'string', error: 'Invalid key' },
                    { valid: riff.scale && typeof riff.scale === 'string', error: 'Invalid scale' },
                    { valid: riff.tempo >= 30 && riff.tempo <= 300, error: 'Invalid tempo' },
                    { valid: riff.measures >= 1 && riff.measures <= 16, error: 'Invalid measure count' }
                ];
                
                for (const check of checks) {
                    if (!check.valid) {
                        return { valid: false, error: check.error };
                    }
                }
                
                // Validate each note
                for (let i = 0; i < riff.notes.length; i++) {
                    const note = riff.notes[i];
                    if (!note.frequency || !note.duration || note.fret === undefined) {
                        return { valid: false, error: `Invalid note at position ${i}` };
                    }
                }
                
                return { valid: true };
            }
            
            validateMusicXMLContent(xml) {
                // BULLETPROOF-9x3 Implementation #1: Multi-Strategy XML Validation
                
                try {
                    // Strategy 1: DOM Parser Validation (Most Reliable)
                    if (typeof DOMParser !== 'undefined') {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(xml, 'text/xml');
                        
                        // Check for parser errors
                        const parserError = xmlDoc.querySelector('parsererror');
                        if (parserError) {
                            console.warn('DOM Parser found error:', parserError.textContent);
                            // Continue to other strategies instead of failing
                        } else {
                            // DOM parsing succeeded - validate structure
                            const scorePartwise = xmlDoc.querySelector('score-partwise');
                            const partList = xmlDoc.querySelector('part-list');
                            const measures = xmlDoc.querySelectorAll('measure');
                            
                            if (scorePartwise && partList && measures.length > 0) {
                                console.log('‚úÖ XML validated via DOM Parser');
                                return true;
                            }
                        }
                    }
                } catch (e) {
                    console.warn('DOM Parser validation failed:', e.message);
                }
                
                // Strategy 2: Essential Elements Check (Fallback)
                const essentialChecks = [
                    { pattern: /<\?xml[^>]*\?>/, name: 'XML Declaration' },
                    { pattern: /<!DOCTYPE[^>]*>/, name: 'DOCTYPE' },
                    { pattern: /<score-partwise[^>]*>/, name: 'score-partwise open' },
                    { pattern: /<\/score-partwise>/, name: 'score-partwise close' },
                    { pattern: /<part-list>/, name: 'part-list open' },
                    { pattern: /<\/part-list>/, name: 'part-list close' },
                    { pattern: /<measure[^>]*>/, name: 'measure' }
                ];
                
                let allEssentialPresent = true;
                for (const check of essentialChecks) {
                    if (!check.pattern.test(xml)) {
                        console.warn(`Missing essential element: ${check.name}`);
                        allEssentialPresent = false;
                    }
                }
                
                if (allEssentialPresent) {
                    console.log('‚úÖ XML validated via essential elements check');
                    return true;
                }
                
                // Strategy 3: Balanced Tag Validation (Most Lenient)
                try {
                    // Remove self-closing tags, comments, and declarations for counting
                    let cleanXml = xml
                        .replace(/<\?[^>]*\?>/g, '') // Remove processing instructions
                        .replace(/<!--[\s\S]*?-->/g, '') // Remove comments
                        .replace(/<!DOCTYPE[^>]*>/g, '') // Remove DOCTYPE
                        .replace(/<([^>]*)\s*\/>/g, ''); // Remove self-closing tags
                    
                    // Extract all tag names
                    const openingTags = [];
                    const closingTags = [];
                    
                    // Match opening tags (excluding self-closing)
                    const openMatches = cleanXml.match(/<([A-Za-z][A-Za-z0-9-]*)[^>]*(?<!\/)>/g) || [];
                    openMatches.forEach(tag => {
                        const tagName = tag.match(/<([A-Za-z][A-Za-z0-9-]*)/);
                        if (tagName) openingTags.push(tagName[1]);
                    });
                    
                    // Match closing tags
                    const closeMatches = cleanXml.match(/<\/([A-Za-z][A-Za-z0-9-]*)>/g) || [];
                    closeMatches.forEach(tag => {
                        const tagName = tag.match(/<\/([A-Za-z][A-Za-z0-9-]*)/);
                        if (tagName) closingTags.push(tagName[1]);
                    });
                    
                    // Check if critical tags are balanced
                    const criticalTags = ['score-partwise', 'part-list', 'part', 'measure'];
                    for (const tagName of criticalTags) {
                        const openCount = openingTags.filter(t => t === tagName).length;
                        const closeCount = closingTags.filter(t => t === tagName).length;
                        if (openCount !== closeCount) {
                            console.warn(`Unbalanced tag: ${tagName} (open: ${openCount}, close: ${closeCount})`);
                            // Don't fail completely, just warn
                        }
                    }
                    
                    // If we have the basic structure, accept it
                    if (xml.includes('<score-partwise') && xml.includes('</score-partwise>')) {
                        console.log('‚úÖ XML validated via balanced tag check');
                        return true;
                    }
                    
                } catch (e) {
                    console.warn('Balanced tag validation error:', e.message);
                }
                
                // If all strategies fail but we have minimal structure, accept with warning
                if (xml.includes('<score-partwise') && xml.includes('</score-partwise>')) {
                    console.warn('‚ö†Ô∏è XML validation incomplete, but basic structure present - proceeding');
                    return true;
                }
                
                console.error('‚ùå XML validation failed all strategies');
                return false;
            }
            
            logExportSuccess(filename, size) {
                const exportLog = {
                    filename: filename,
                    size: size,
                    timestamp: new Date(),
                    riffParams: {
                        key: this.currentRiff.key,
                        scale: this.currentRiff.scale,
                        measures: this.currentRiff.measures,
                        noteCount: this.currentRiff.notes.length
                    }
                };
                console.log('Export successful:', exportLog);
            }

            generateMusicXML(riff) {
                // BULLETPROOF-9x3: Triple-validated XML generation
                if (!riff || !riff.notes || riff.notes.length === 0) {
                    throw new Error('Invalid riff data for MusicXML generation');
                }
                
                const divisions = 4; // 16th note resolution
                const tempo = riff.tempo || 120;
                const measures = riff.measures || 4;
                
                // Start building XML with string concatenation for reliability
                const xmlParts = [];
                
                // XML Declaration and DOCTYPE
                xmlParts.push('<?xml version="1.0" encoding="UTF-8" standalone="no"?>');
                xmlParts.push('<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">');
                
                // Score opening
                xmlParts.push('<score-partwise version="3.1">');
                
                // Work information
                xmlParts.push('  <work>');
                xmlParts.push('    <work-title>GML-RiffGen Export</work-title>');
                xmlParts.push('  </work>');
                
                // Identification
                xmlParts.push('  <identification>');
                xmlParts.push('    <creator type="composer">GML-RiffGen V1.2.0</creator>');
                xmlParts.push('    <encoding>');
                xmlParts.push('      <software>GML-RiffGen V1.2.0 BULLETPROOF-9x3</software>');
                xmlParts.push(`      <encoding-date>${new Date().toISOString().split('T')[0]}</encoding-date>`);
                xmlParts.push('    </encoding>');
                xmlParts.push('  </identification>');
                
                // Part list
                xmlParts.push('  <part-list>');
                xmlParts.push('    <score-part id="P1">');
                xmlParts.push('      <part-name>Electric Guitar</part-name>');
                xmlParts.push('      <part-abbreviation>E.Gtr.</part-abbreviation>');
                xmlParts.push('    </score-part>');
                xmlParts.push('  </part-list>');
                
                // Part
                xmlParts.push('  <part id="P1">');
                
                // Group notes by measure safely
                const notesPerMeasure = this.groupNotesByMeasure(riff.notes, measures);
                
                // Generate each measure
                for (let measureNum = 1; measureNum <= measures; measureNum++) {
                    xmlParts.push(`    <measure number="${measureNum}">`);
                    
                    // Add attributes only to first measure
                    if (measureNum === 1) {
                        xmlParts.push('      <attributes>');
                        xmlParts.push(`        <divisions>${divisions}</divisions>`);
                        xmlParts.push('        <key>');
                        xmlParts.push(`          <fifths>${this.keyToFifths(riff.key)}</fifths>`);
                        xmlParts.push('        </key>');
                        xmlParts.push('        <time>');
                        xmlParts.push('          <beats>4</beats>');
                        xmlParts.push('          <beat-type>4</beat-type>');
                        xmlParts.push('        </time>');
                        xmlParts.push('        <clef>');
                        xmlParts.push('          <sign>TAB</sign>');
                        xmlParts.push('          <line>5</line>');
                        xmlParts.push('        </clef>');
                        xmlParts.push('      </attributes>');
                        
                        // Add tempo direction
                        xmlParts.push('      <direction placement="above">');
                        xmlParts.push('        <direction-type>');
                        xmlParts.push('          <metronome>');
                        xmlParts.push('            <beat-unit>quarter</beat-unit>');
                        xmlParts.push(`            <per-minute>${tempo}</per-minute>`);
                        xmlParts.push('          </metronome>');
                        xmlParts.push('        </direction-type>');
                        xmlParts.push(`        <sound tempo="${tempo}"/>`);
                        xmlParts.push('      </direction>');
                    }
                    
                    // Add notes for this measure
                    const measureNotes = notesPerMeasure[measureNum - 1] || [];
                    
                    if (measureNotes.length === 0) {
                        // Add whole rest if measure is empty
                        xmlParts.push('      <note>');
                        xmlParts.push('        <rest/>');
                        xmlParts.push(`        <duration>${divisions * 4}</duration>`);
                        xmlParts.push('        <type>whole</type>');
                        xmlParts.push('      </note>');
                    } else {
                        // Process each note
                        let currentBeat = 0;
                        
                        for (const note of measureNotes) {
                            // Add rest if there's a gap
                            const beatGap = (note.beat % 4) - currentBeat;
                            if (beatGap > 0.01) {
                                const restDuration = Math.round(beatGap * divisions);
                                xmlParts.push('      <note>');
                                xmlParts.push('        <rest/>');
                                xmlParts.push(`        <duration>${restDuration}</duration>`);
                                xmlParts.push(`        <type>${this.durationToType(beatGap)}</type>`);
                                xmlParts.push('      </note>');
                                currentBeat += beatGap;
                            }
                            
                            // Add the note
                            try {
                                const pitch = this.frequencyToPitch(note.frequency);
                                const duration = Math.min(Math.round(note.duration * divisions), divisions * 4);
                                
                                xmlParts.push('      <note>');
                                xmlParts.push('        <pitch>');
                                xmlParts.push(`          <step>${pitch.step}</step>`);
                                if (pitch.alter) {
                                    xmlParts.push(`          <alter>${pitch.alter}</alter>`);
                                }
                                xmlParts.push(`          <octave>${pitch.octave}</octave>`);
                                xmlParts.push('        </pitch>');
                                xmlParts.push(`        <duration>${duration}</duration>`);
                                xmlParts.push(`        <type>${this.durationToType(note.duration)}</type>`);
                                xmlParts.push('        <notations>');
                                xmlParts.push('          <technical>');
                                xmlParts.push(`            <string>${this.getStringNumber(note.string)}</string>`);
                                xmlParts.push(`            <fret>${Math.max(0, Math.min(24, note.fret))}</fret>`);
                                xmlParts.push('          </technical>');
                                xmlParts.push('        </notations>');
                                xmlParts.push('      </note>');
                                
                                currentBeat += note.duration;
                            } catch (noteError) {
                                console.warn('Error processing note:', noteError);
                                // Skip problematic note
                            }
                        }
                        
                        // Fill rest of measure if needed
                        if (currentBeat < 3.99) { // Allow small rounding errors
                            const remainingDuration = Math.round((4 - currentBeat) * divisions);
                            if (remainingDuration > 0) {
                                xmlParts.push('      <note>');
                                xmlParts.push('        <rest/>');
                                xmlParts.push(`        <duration>${remainingDuration}</duration>`);
                                xmlParts.push(`        <type>${this.durationToType((4 - currentBeat))}</type>`);
                                xmlParts.push('      </note>');
                            }
                        }
                    }
                    
                    // Close measure
                    xmlParts.push('    </measure>');
                }
                
                // Close part
                xmlParts.push('  </part>');
                
                // Close score
                xmlParts.push('</score-partwise>');
                
                // Join all parts with newlines
                const xml = xmlParts.join('\n');
                
                // Final validation
                const openScoreCount = (xml.match(/<score-partwise/g) || []).length;
                const closeScoreCount = (xml.match(/<\/score-partwise>/g) || []).length;
                
                if (openScoreCount !== closeScoreCount) {
                    console.error('XML generation error: unbalanced score-partwise tags');
                    throw new Error('XML generation failed: unbalanced tags');
                }
                
                return xml;
            }
            
            
            groupNotesByMeasure(notes, measureCount) {
                const groups = Array(measureCount).fill(null).map(() => []);
                const beatsPerMeasure = 4;
                
                notes.forEach(note => {
                    const measureIndex = Math.floor(note.beat / beatsPerMeasure);
                    if (measureIndex < measureCount) {
                        groups[measureIndex].push({
                            ...note,
                            beat: note.beat % beatsPerMeasure
                        });
                    }
                });
                
                // Sort notes within each measure
                groups.forEach(group => {
                    group.sort((a, b) => a.beat - b.beat);
                });
                
                return groups;
            }
            
            frequencyToPitch(frequency) {
                // More accurate frequency to pitch conversion
                const a4 = 440;
                const a4Pitch = 69; // MIDI number for A4
                
                const midiNumber = Math.round(12 * Math.log2(frequency / a4) + a4Pitch);
                
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const pitchClass = midiNumber % 12;
                const octave = Math.floor(midiNumber / 12) - 1;
                
                let step = noteNames[pitchClass].replace('#', '');
                let alter = noteNames[pitchClass].includes('#') ? 1 : 0;
                
                // Handle enharmonic equivalents for better readability
                if (step === 'C' && alter === 1) {
                    step = 'C';
                    alter = 1;
                } else if (step === 'D' && alter === 1) {
                    step = 'D';
                    alter = 1;
                } else if (step === 'F' && alter === 1) {
                    step = 'F';
                    alter = 1;
                } else if (step === 'G' && alter === 1) {
                    step = 'G';
                    alter = 1;
                } else if (step === 'A' && alter === 1) {
                    step = 'A';
                    alter = 1;
                }
                
                return { step, alter, octave };
            }
            
            keyToFifths(key) {
                // Convert key to circle of fifths notation
                const fifthsMap = {
                    'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5,
                    'F#': 6, 'C#': 7, 'F': -1, 'Bb': -2, 'Eb': -3,
                    'Ab': -4, 'Db': -5, 'Gb': -6, 'A#': -2, 'D#': -3,
                    'G#': -4
                };
                return fifthsMap[key] || 0;
            }

            durationToType(duration) {
                // Enhanced duration mapping with BULLETPROOF validation
                if (duration >= 4) return 'whole';
                if (duration >= 2) return 'half';
                if (duration >= 1) return 'quarter';
                if (duration >= 0.5) return 'eighth';
                if (duration >= 0.25) return 'sixteenth';
                if (duration >= 0.125) return 'thirty-second';
                return 'sixty-fourth';
            }

            getStringNumber(stringName) {
                const strings = { 'e': 1, 'B': 2, 'G': 3, 'D': 4, 'A': 5, 'E': 6 };
                return strings[stringName] || 1;
            }

            getParameters() {
                return {
                    key: document.getElementById('key').value,
                    scale: document.getElementById('scale').value,
                    tempo: parseInt(document.getElementById('tempo').value),
                    measures: parseInt(document.getElementById('measures').value),
                    complexity: parseInt(document.getElementById('complexity').value),
                    volume: parseInt(document.getElementById('volume').value),
                    distortion: parseInt(document.getElementById('distortion').value)
                };
            }

            validateParameters(params) {
                return this.bp93.validate('runtime', () => {
                    return params.key && params.scale && 
                           params.tempo >= 60 && params.tempo <= 200 &&
                           params.measures >= 1 && params.measures <= 8 &&
                           params.complexity >= 1 && params.complexity <= 10;
                }, 'Invalid parameters detected');
            }

            showLoading(show) {
                const spinner = document.getElementById('loadingSpinner');
                if (spinner) {
                    spinner.style.display = show ? 'block' : 'none';
                }
            }

            updateStatus(message) {
                console.log(`[STATUS] ${message}`);
            }

            // Diagnostic functions for BULLETPROOF-9x3
            runDiagnostics() {
                const diagnostics = this.bp93.getDiagnostics();
                const content = document.getElementById('diagnosticsContent');
                
                content.innerHTML = `
                    <p>Errors: ${diagnostics.errors.length}</p>
                    <p>Warnings: ${diagnostics.warnings.length}</p>
                    <p>Layer Status: ${JSON.stringify(diagnostics.layerStatus)}</p>
                    <p>Last Check: ${diagnostics.timestamp}</p>
                `;
                
                document.getElementById('diagnostics').style.display = 'block';
            }
        }

        // Initialize application with BULLETPROOF-9x3 protection
        let riffGenerator = null;

        document.addEventListener('DOMContentLoaded', () => {
            try {
                riffGenerator = new RiffGenerator();
                
                // Add diagnostic trigger (Ctrl+Shift+D)
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                        riffGenerator.runDiagnostics();
                    }
                });
                
            } catch (error) {
                console.error('Critical initialization error:', error);
                document.body.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <h1>Initialization Error</h1>
                        <p>Failed to initialize GML-RiffGen: ${error.message}</p>
                        <p>Please refresh the page or check browser compatibility.</p>
                    </div>
                `;
            }
        });

        // Global error handler (Layer 3: UX Safety)
        window.addEventListener('error', (event) => {
            console.error('Global error caught:', event.error);
            if (riffGenerator && riffGenerator.bp93) {
                riffGenerator.bp93.logError('ux', `Unhandled error: ${event.error.message}`, false);
            }
        });

        // Prevent unload if audio is playing
        window.addEventListener('beforeunload', (event) => {
            if (riffGenerator && riffGenerator.isPlaying) {
                event.preventDefault();
                event.returnValue = 'Audio is still playing. Are you sure you want to leave?';
            }
        });
    </script>

<!-- GML Template System -->
<script src="https://raw.githubusercontent.com/mikeb55/-gml-enhancement-suite/main/templates/TemplateSystem.js"></script>
<script>
window.addEventListener("DOMContentLoaded", async () => {
    try {
        window.templateSystem = new TemplateSystem();
        await window.templateSystem.init();
        let c = document.getElementById("controls") || document.querySelector(".controls") || document.body;
        window.templateSystem.createDropdown(c.id || "controls", (g,t) => console.log("Template loaded:", g));
    } catch(e) { console.log("Template System load error:", e); }
});
</script>
</body>
</html>
